# 内存管理总结

## 内存管理流程：

1. 新进程有一个task_struct结构体管理该进程；
2. task_struct中初始化一个mm_struct用于管理该进程的所有虚拟内存空间；
3. 需要新内存时申请一个新的vma（用一个vm_area_struct管理）并申请、映射一块物理页；
4. 缺页时执行页置换算法。

## linux系统使用的算法：

物理内存管理算法：伙伴系统的基础上使用slab分配器进一步细化分配。

局部页面置换算法:单一进程内页面置换使用，最近最少使用（LRU）页面的衰老算法。

虚拟内存管理数据结构：`vm_area_struct`对应ucoreOS中的`vmm_struct`区别是vma数目较少时linux使用链表按升序存储，vma数量较多后改为使用AVL树存储以提高搜索速度。

## linux内存管理数据结构图：

![linux内存管理数据结构图](E:\onedrive\文档\markdown笔记\操作系统\图片\linux内存管理数据结构图.jpg)

## 其他知识点

### 页的分类：

内核有一个物理页表，每个进程有一个各自的虚拟页表

- 物理页表：二级页表，仅操作系统维护一个，4KB页目录项，和多个4KB页表项，以及这些页表对应的多个4KB物理页，存放在内存固定位置。
- 虚拟页表：二级页表，每个进程都有一个，4KB页目录项，和多个4KB页表项，页表会映射到物理地址上，二级页表中保存有该虚拟页对应的物理页的线性地址，再通过线性地址，区物理页表的页目录项、页表项找对应的物理页物理地址。（应该是这样吧，不确定）

### 虚拟页到物理页的映射（32位系统）：

- 通过该进程页表索引
- 高10bit索引页目录项的4KB空间，每4B索引一个二级页表项，刚好1024个，被10bit索引
- 中10bit索引二级页表项4KB空间，每4B索引一个物理页地址，刚好1024个，被10bit索引
- 低12bit为索引物理页中的偏移地址，一个物理页4KB，刚好被12bit索引

### 物理内存管理：

连续内存分配算法：

- 分配策略（策略，不是算法，算法根据不同策略实现）：最先、最佳、最差匹配，找到分配出去的物理块；
- 分配算法：linux中用的是伙伴系统(buddy system)，并在其基础上实现slab分配器，这两个算法；

非连续内存分配算法：

- 非连续内存基于段、页、段页式内存管理方法来实现非连续内存的管理与分配。

最终linux的物理页管理方面，使用的是二级页式管理，算法使用buddy system+slab分配器。

### 虚拟内存管理：

虚拟内存管理的主要数据结构：mm_struct, vm_area_struct，一个进程有一个mm_struct和多个vm_area_struct

mm_struct中有两个vm_area_struct的指针，一个是链表头指针，用于遍历vma，另一个是红黑树根节点指针，用于查找指定vma。

局部页置换算法：用于进程内选择置换哪个页出去，常见算法有：OPF,FIFO,LRU,clock,LFU。

全局页置换算法：用于整个操作系统中决定每个进程应该保留多少页（常驻集），常见算法有：工作集置换算法、缺页率置换算法。

linux使用的是LRU置换算法+缺页率置换算法。LRU性能接近OPT但是实现困难开销大，所以实际采用的是其近似算法：clock置换算法或者clock算法的变体。

