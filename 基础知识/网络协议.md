# 网络协议

[TOC]

## 参考文献

[Vamei协议森林系列博客](https://www.cnblogs.com/vamei/tag/%E7%BD%91%E7%BB%9C/)

[TCP的工作原理,TCP的流量控制原理，滑动窗口，拥塞窗口，ACK累计确认等](https://blog.csdn.net/ifpelset/article/details/15378005)

wiki：

- [nagle算法](https://zh.wikipedia.org/wiki/%E7%B4%8D%E6%A0%BC%E7%AE%97%E6%B3%95)
- [最大分段大小](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%88%86%E6%AE%B5%E5%A4%A7%E5%B0%8F)
- [传输控制协议TCP](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)
- [以太网帧格式](https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F)

# 连接层协议

## 以太网与WIFI协议

以太网和WiFi是连接层的两种协议。在连接层，信息以帧(frame)为单位传输。帧像信封一样将数据(payload)包裹起来，并注明收信地址和送信地址。连接层实现了“本地社区”的通信。

### 以太网帧格式

| Preamble | SFD   | DST   | SRC   | 802.1Q标签(可选) | Type  | Payload (Data) | Pad  | FCS   | Extension |
| -------- | ----- | ----- | ----- | ---------------- | ----- | -------------- | ---- | ----- | --------- |
| 7Byte    | 1Byte | 6Byte | 6Byte | 4Byte            | 2Byte | 46-1500Byte    |      | 4Byte | 12Byte    |

整个以太帧大小在84-1542Byte之间。

帧由头部、数据(Payload)、尾部三部分组成。

头部：

- 序言(preamble)：7Byte的0xAA。0XAA的二进制是10101010b，通过按一定频率发0/1序列，调节发收双方的通信频率，使得接收方的频率于发送方一致（接收方调频匹配接收方），这个过程叫做时钟复原(recover the clock)；
- 起始信号(SFD, start frame delimiter)：SFD是固定的值0xAB(10101011b)，顾名思义，就是起始信号，在时钟复原后最后连发两个11表示要正式开始通信了；
- 目的地(DST, destination)和发出地(SRC, source)：发收双方的MAC地址；
- 类型(Type)：说明数据部分类型，例如0x0800为IPv4，0x0806为ARP

数据：

- Payload：数据部分，可能是IP包，可能是ARP包等。
- PAD：填充部分，当数据短于最小长度时，用0填充数据尾。

尾部：

- 校验序列(FCS, Frame Check Sequence)：校验序列用于检验数据传输的正确性。FCS采用32位了冗余校验(CRC, Cyclic Redundancy Check)算法。
- 帧间距(Extension)：当一个帧发送出去之后，发送方在下次发送帧之前，需要再发送至少12个octet（八位字组，类似Byte）的空闲线路状态码。

### 集线器与交换机

以太网使用集线器或者交换器将帧从发出地传送到目的地。一台集线器或交换器上有多个端口，每个端口都可以连接一台计算机(或其他设备)。

**集线器**：像一个广播电台。一台电脑将帧发送到集线器，集线器会将帧转发到所有其他的端口。每台计算机检查自己的MAC地址是不是符合DST。如果不是，则保持沉默。集线器是比较早期的以太网设备。它有明显的缺陷：

- 任意两台电脑的通信在同一个以太网上是公开的。所有连接在同一个集线器上的设备都能收听到别人在传输什么，这样很不安全。可以通过对信息加密提高安全性。
- 不允许多路同时通信。如果两台电脑同时向集线器发信，集线器会向所有设备发出“冲突”信息，提醒发生冲突。可以在设备上增加冲突检测算法(collision detection)：一旦设备发现有冲突，则随机等待一段时间再重新发送。

**交换器**：克服集线器的缺陷。交换器记录有各个设备的MAC地址。当帧发送到交换器时，交换器会检查DST，然后将帧只发送到对应端口。交换器允许多路同时通信。由于交换器的优越性，交换器基本上取代了集线器。但比较老的以太网还有可能在使用集线器。

**WiFi**：WIFI的工作方式与集线器连接下的以太网类似。一个WiFi设备会向所有的WiFi设备发送帧，其它的WiFi设备检查自己是否符合DST。由于WiFi采取无线电信号，所以很难像交换器一样定向发送，所以WiFi的安全性很值得关注。WiFi采用加密的方法来实现信息的安全性。

> 早期的WEP加密方法非常脆弱，建议使用WPA或者WPA2加密方法。隐藏WiFi设备ID的方法不是很有用。

# 网络层协议

## IP协议

socket对TCP/IP协议的封装，这不是系统调用，而是一个库。

### IP包结构

IP数据包由头部和数据两部分构成。IPv4与IPv6数据结构不同。

IPv6的主要目的是增加IPv4的地址容量，但同时根据IPv4的经验和新时代的技术进步进行改进，比如避免碎片化，比如取消checksum (由于高层协议TCP的广泛使用)。网络协议技术上并不复杂，更多的考量是政策性的。

IPv4与IPv6结构如下：

![IPv4与IPv6结构](https://pic002.cnblogs.com/images/2012/413416/2012120111475858.gif)

黄色区域 （同名区域）：

- Version(4位)：用来表明IP协议版本，是IPv4还是IPv6(IPv4, Version=0100; IPv6, Version=0110)。
- Source Adrresss和Destination Address：分别为发出地和目的地的IP地址。

蓝色区域（名字发生变动的区域）：

- Time to Live 存活时间(Hop Limit in IPv6)：Time to Live最初是表示一个IP包的最大存活时间：如果IP包在传输过程中超过Time to Live，那么IP包就作废。后来，IPv4的这个区域记录一个整数(比如30)，表示在IP包接力过程中最多经过30个路由接力，如果超过30个路由接力，那么这个IP包就作废。IP包每经过一个路由器，路由器就给Time to Live减一。当一个路由器发现Time to Live为0时，就不再发送该IP包。IPv6中的Hop Limit区域记录的也是最大路由接力数，与IPv4的功能相同。Time to Live/Hop Limit避免了IP包在互联网中无限接力。
- Type of Service 服务类型(Traffic Class in IPv6)：Type of Service最初是用来给IP包分优先级，比如语音通话需要实时性，所以它的IP包应该比Web服务的IP包有更高的优先级。然而，这个最初不错的想法没有被微软采纳。在Windows下生成的IP包都是相同的最高优先级，所以在当时造成Linux和Windows混合网络中，Linux的IP传输会慢于Windows (仅仅是因为Linux更加守规矩！)。后来，Type of Service被实际分为两部分：Differentiated Service Field (DS, 前6位)和Explicit Congestion Notification (ECN, 后2位)，前者依然用来区分服务类型，而后者用于表明IP包途径路由的交通状况。IPv6的Traffic Class也被如此分成两部分。通过IP包提供不同服务的想法，并针对服务进行不同的优化的想法已经产生很久了，但具体做法并没有形成公认的协议。比如ECN区域，它用来表示IP包经过路径的交通状况。如果接收者收到的ECN区域显示路径上的很拥挤，那么接收者应该作出调整。但在实际上，许多接收者都会忽视ECN所包含的信息。交通状况的控制往往由更高层的比如TCP协议实现（堵塞控制）。
- Protocol 协议(Next Header in IPv6)：Protocol用来说明IP包Payload部分所遵循的协议，也就是IP包之上的协议是什么。它说明了IP包封装的是一个怎样的高层协议包(TCP\UDP)。
- Total Length(Payload Length in IPv6)：分别是IPv4包的总长度和IPv6包的数据部长度，因为IPv4头长度不固定所以要算总长，IPv6头长度固定，只需要数据部分长度+40Byte即可。

红色区域（IPv6中删除的区域）：

- options：每个options有32位，是选填性质的区域。一个IPv4头部可以完全没有options区域，所以这个区域导致IPv4的头长度是变动的，所以需要IHL记录头部总长度，Total Length记录IP包总长度；
- IHL(Internet Header Length)：记录IPv4头总长度，由于options端变动才需要；
- Header checksum：校验IP包头部信息的校验和，IPv6不再校验，而是把校验工作彻底交给高层协议完成了，免去了校验费时，减小了网络延迟(latency)。
- Identification, flags和fragment offset，这三个包都是为碎片化(fragmentation)服务的。
  - 碎片化是指一个路由器将接收到的IP包分拆成多个IP包传送，而接收这些“碎片”的路由器或者主机需要将“碎片”重新组合(reassembly)成一个IP包。
  - 不同的局域网所支持的最大传输单元(MTU, Maximum Transportation Unit)不同。如果一个IP包的大小超过了局域网支持的MTU，就需要在进入该局域网时碎片化传输。
  - 碎片化会给路由器和网络带来很大的负担。最好在IP包发出之前探测整个路径上的最小MTU，IP包的大小不超过该最小MTU，就可以避免碎片化。
  - IPv6在设计上避免碎片化。每一个IPv6局域网的MTU都必须大于等于1280 bytes。IPv6的默认发送IP包大小为1280 bytes。
- Padding：这个字段以额外的0来填充IP报头,以确保其长度为32 bit的倍数。 其后就是数据字段。

绿色区域（IPv6新增区域）：

- Flow Label是IPv6中新增的区域。它被用来提醒路由器来重复使用之前的接力路径。这样IP包可以自动保持出发时的顺序。这对于流媒体之类的应用有帮助。Flow label的进一步使用还在开发中。

### 校验和计算

IPv4的校验和为16bit，所以将这个IPv4头拆分成16bit一组相加，出现超过16bit的进位则在最后一位加一。

例如:0xFFFF + 0x0002 = 0x10001 = 0x0002​

### IP包接力

#### IP包接力流程

IP地址实际上识别的是网卡(NIC, Network Interface Card)。网卡是计算机的一个硬件，它在接收到网路信息之后，将信息交给计算机(处理器/内存)。当计算机需要发送信息的时候，也要通过网卡发送。一台计算机可以有不只一个网卡，比如笔记本就有一个以太网卡和一个WiFi网卡。计算机在接收或者发送信息的时候，要先决定想要通过哪个网卡。路由器(router)实际上就是一台配备有多个网卡的专用电脑，让多个网卡接入到不同的网络中。

每个主机和路由器上都维护由路由表，路由表举例如下：

| Destination   | Gateway        | Genmask       | Iface |
| ------------- | -------------- | ------------- | ----- |
| 199.165.145.0 | 0.0.0.0        | 255.255.255.0 | eth0  |
| 0.0.0.0       | 199.165.145.17 | 0.0.0.0       | eth0  |

- Destination是能连接到的IP地址或IP子网（具体是子网还是地址要结合Genmask确定），后面是去往那里要经过的网关，0.0.0.0前面路由表中没有的IP全部发往这个地址对应的网关。
- Gateway是到Destination要经过的网关，0.0.0.0表示本地直连。
- Genmask是子网掩码。
- Iface是要用的网卡名。

> linux中可以通过route -n查看路由表。
>
> 该接力流程同样适用于IPv6，但细节不同，例如IPv6使用NDP协议替代ARP协议。

IP包每到一个路由就对照路由表确定下一步路线，然后打包成以太帧发往相应网关或者主机。这中间需要知道IP与MAC的对应关系(ARP协议)，并再各主机、路由上生成正确的路由表(RIP协议)。

#### ARP协议

地址解析协议(ARP, Address Resolution Protocol)，用于生成正确的IP和MAC对应关系。通过ARP协议将传播IP地址与MAC地址的对应关系到局域网的每个主机和路由。每一台主机或路由中都有一个ARP cache，用以存储局域网内IP地址和MAC地址如何对应。

ARP协议(ARP介于连接层和网络层之间，ARP包需要包裹在一个帧中)的工作方式如下：

1. 主机会发出一个ARP包，该ARP包中包含有自己的IP地址和MAC地址。
2. 通过ARP包，主机以广播的形式询问局域网上所有的主机和路由：我是IP地址xxxx，我的MAC地址是xxxx，有人知道199.165.146.4的MAC地址吗？
3. 拥有该IP地址的主机会回复发出请求的主机：哦，我知道，这个IP地址属于我的一个NIC，它的MAC地址是xxxxxx。
4. 由于发送ARP请求的主机采取的是广播形式，并附带有自己的IP地址和MAC地址，其他的主机和路由会同时检查自己的ARP cache，如果不符合，则更新自己的ARP cache。
5. 这样，经过几次ARP请求之后，ARP cache会达到稳定。如果局域网上设备发生变动，ARP重复上面过程。

在Linux下，可以使用`$arp`命令来查看ARP的过程。ARP协议只用于IPv4。IPv6使用NDP(Neighbor Discovery Protocol)协议来替代ARP的功能。IPv6包通过邻居探索(ND, Neighbor Discovery)来实现ARP的功能。ND的工作方式与ARP类似，但它基于ICMP协议。ICMP包有Neighbor Solicitation和Neighbor Advertisement类型。这两个类型分别对应ARP协议的询问和回复信息。

#### RIP协议

路由信息协议(RIP, Routing Information Protocol)是一种自动生成路由表的协议。

- RIP通过距离来决定路由表，所以属于distance-vector protocol；
- 距离的定义是：从出发地到目的地途径的路由器数目(hop number)；
- 在各个点不断重复RIP广播/计算距离/更新routing table的过程，最终所有的主机和路由器都能生成最合理的路径(merge)；
- RIP出于技术上的原因(looping hops)，认为距离超过15的IP不可到达；
- RIP协议主要用于一个自治系统(AS, autonomous system)，自治系统（例如整个中国电信的网络）与外界的通信（例如电信网去联通区玩游戏）通过边界路由器和BGP协议完成。BGP的基本工作过程与RIP类似，但在考虑距离的同时，也权衡比如政策、连接性能等其他因素，再决定交通的走向(routing table)。

### IP协议的可靠性和效率

IP协议是不可靠的，效率优先的。IP协议是"Best Effort"式的，IP传输是不可靠的。但这样的设计成就了IP协议的效率。

不可靠：IP包会在checksum错误或Time to Live超过后，直接丢弃IP包。Best effort让IP协议保持很简单的形态。更多的质量控制交给高层协议处理，IP协议只负责有效率的传输。

效率：即使出发地和目的地保持不变，IP协议也不保证IP包到达的先后顺序。如果在连续的IP包发送过程中，routing table更新(比如有一条新建的捷径出现)，那么后发出的IP包选择走不一样的接力路线。如果新的路径传输速度更快，那么后发出的IP包有可能先到（效率最大）。

> IPv6中的Flow Label可以建议路由器将一些IP包保持一样的接力路径。但这只是“建议”，路由器可能会忽略该建议。
>
> IP协议在产生时是一个松散的网络，这个网络由各个大学的局域网相互连接成的，由一群碰头垢面的Geek维护。所以，IP协议认为自己所处的环境是不可靠(unreliable)的：诸如路由器坏掉、实验室失火、某个PhD踢掉电缆之类的事情随时会发生。

### IPv4地址不足的临时解决方案

CIDR和NAT在IPv6中同样被采用。

#### CIDR

随意分割IP地址端，不再只按ABC级分子网，例如：199.165.145.254/31，分割出一个只有两个IP地址的子网。

#### NAT

使用私有IP通过由NAT功能的网关路由器与外网通信，内网用私有IP不受外网影响，在不同内网可以使用相同私有IP。

NAT所处的网关服务器是理想的设置防火墙的位置，NAT还往往和防火墙共同建设，以提高私有网络的安全性。

## ICMP协议

ICMP(Internet Control Message Protocol)是介于网络层和传输层的协议，它的主要功能是传输网络诊断信息。ICMP协议时IP协议的一个重要补充。

ICMP基于IP协议。也就是说，一个ICMP包需要封装在IP包中，然后在互联网传送。ICMP是IP套装的必须部分，也就是说，任何一个支持IP协议的计算机，都要同时实现ICMP。

ICMP协议是实现ping命令和traceroute命令的基础。这两个工具常用于网络排错。

ICMP包通常是由某个IP包触发的。这个触发IP包的头部和一部份数据会被包含在ICMP包的数据部分。

尽管ICMP的设计是出于好的意图，但ICMP却经常被黑客借用进行网络攻击，比如利用伪造的IP包引发大量的ICMP回复，并将这些ICMP包导向受害主机，从而形成DoS攻击。而redirect类型的ICMP包可以引起某个主机更改自己的routing table，所以也被用作攻击工具。许多站点选择忽视某些类型的ICMP包来提高自身的安全性。

### ICMP信息类型

ICMP传输的信息可以分为两类：

- 错误(error)信息，这一类信息可用来诊断网络故障。我们已经知道，IP协议的工作方式是“Best Effort”，如果IP包没有被传送到目的地，或者IP包发生错误，IP协议本身不会做进一步的努力。但上游发送IP包的主机和接力的路由器并不知道下游发生了错误和故障，它们可能继续发送IP包。通过ICMP包，下游的路由器和主机可以将错误信息汇报给上游，从而让上游的路由器和主机进行调整。需要注意的是，ICMP只提供特定类型的错误汇报，**它不能帮助IP协议成为“可靠”(reliable)的协议**。
- 咨询(Informational)性质的信息，比如某台计算机询问路径上的每个路由器都是谁，然后各个路由器同样用ICMP包回答。

### ICMP包结构

![ICMP包结构](https://pic002.cnblogs.com/images/2012/413416/2012120510270694.png)

ICMP包都会有Type, Code和Checksum三部分。

- Type表示ICMP包的大的类型；
- Code是一个Type之内细分的小类型；
- 针对不同的错误信息或者咨询信息，会有不同的Type和Code
- 从上面我们可以看到，ICMP支持的类型非常多，有各种各样的功能。Checksum与IP协议的header checksum相类似，但与IP协议中checksum只校验头部不同，这里的Checksum所校验的是整个ICMP包(包括头部和数据)。

### 常见ICMP包类型

回音(Echo)：属于咨询信息。ping命令就是利用了该类型的ICMP包。当使用ping命令的时候，将向目标主机发送Echo-询问类型的ICMP包，而目标主机在接收到该ICMP包之后，会回复Echo-回答类型的ICMP包，并将询问ICMP包包含在数据部分。

源头冷却(source quench)：属于错误信息。如果某个主机快速的向目的地传送数据，而目的地主机没有匹配的处理能力，目的地主机可以向出发主机发出该类型的ICMP包，提醒出发主机放慢发送速度(请温柔一点吧)。

目的地无法到达(Destination Unreachable)：属于错误信息。如果一个路由器接收到一个没办法进一步接力的IP包，它会向出发主机发送该类型的ICMP包。比如当IP包到达最后一个路由器，路由器发现目的地主机down机，就会向出发主机发送目的地无法到达(Destination Unreachable)类型的ICMP包。目的地无法到达还可能有其他的原因，比如不存在接力路径，比如不被接收的端口号等等。

超时(Time Exceeded)：属于错误信息。IPv4中的Time to Live(TTL)和IPv6中的Hop Limit会随着经过的路由器而递减，当这个区域值减为0时，就认为该IP包超时(Time Exceeded)。Time Exceeded就是TTL减为0时的路由器发给出发主机的ICMP包，通知它发生了超时错误。

>  traceroute就利用了这种类型的ICMP包。traceroute命令用来发现IP接力路径(route)上的各个路由器。它向目的地发送IP包，第一次的时候，将TTL设置为1，引发第一个路由器的Time Exceeded错误。这样，第一个路由器回复ICMP包，从而让出发主机知道途径的第一个路由器的信息。随后TTL被设置为2、3、4，...，直到到达目的主机。这样，沿途的每个路由器都会向出发主机发送ICMP包来汇报错误。traceroute将ICMP包的信息打印在屏幕上，就是接力路径的信息了。

重新定向(redirect)：属于错误信息。当一个路由器收到一个IP包，对照其routing table，发现自己不应该收到该IP包，它会向出发主机发送重新定向类型的ICMP，提醒出发主机修改自己的routing table。



# 传输层协议

随着我们进入传输层，我们也可以调用操作系统中的API，来构建socket。Socket是操作系统提供的一个编程接口，它用来代表某个网络通信。应用程序通过socket来调用系统内核中处理网络协议的模块，而这些内核模块会负责具体的网络协议的实施。这样，我们可以让内核来接收网络协议的细节，而我们只需要提供所要传输的内容就可以了，内核会帮我们控制格式，并进一步向底层封装。因此，在实际应用中，我们并不需要知道具体怎么构成一个UDP包，而只需要提供相关信息(比如IP地址，比如端口号，比如所要传输的信息)，操作系统内核会在传输之前会根据我们提供的相关信息构成一个合格的UDP包(以及下层的包和帧)。

## UDP协议

传输层最重要的协议为TCP协议和UDP协议。这两者使用“网”的方式走了两个极端。两个协议的对比非常有趣。TCP协议复杂，但传输可靠。UDP协议简单，但传输不可靠。其他的各个传输层协议在某种程度上都是这两个协议的折中。

**如果已经掌握了IP协议，那么UDP协议就没有任何困难可言，它只是IP协议暴露在传输层上的接口。**

UDP(User Datagram Protocol)传输与IP传输非常类似。你可以将UDP协议看作IP协议暴露在传输层的一个接口。UDP协议同样以数据包(datagram)的方式传输，它的传输方式也是"Best Effort"的，所以UDP协议也是不可靠的(unreliable)。那么，我们为什么不直接使用IP协议而要额外增加一个UDP协议呢？ 一个重要的原因是IP协议中并没有端口(port)的概念。

尽管UDP协议非常简单，但它的产生晚于更加复杂的TCP协议。早期的网络开发者开发出IP协议和TCP协议分别位于网络层和传输层，所有的通信都要先经过TCP封装，再经过IP封装(应用层->TCP->IP)。开发者将TCP/IP视为相互合作的套装。但很快，网络开发者发现，IP协议的功能和TCP协议的功能是相互独立的。对于一些简单的通信，我们只需要“Best Effort”式的IP传输就可以了，而不需要TCP协议复杂的建立连接的方式(特别是在早期网络环境中，如果过多的建立TCP连接，会造成很大的网络负担，而UDP协议可以相对快速的处理这些简单通信)。UDP协议随之被开发出来，作为IP协议在传输层的"傀儡"。这样，网络通信可以通过应用层->UDP->IP的封装方式，绕过TCP协议。由于UDP协议本身异常简单，实际上只为IP传输起到了桥梁的作用。

UDP协议除了点对点（端口到端口）通信外，还支持广播通信，将UDP包发送到网络的广播地址，每个设备都能收到。

### UDP数据包结构

UDP数据包分为头(header)和数据(payload)两部分。

UDP数据包头部结构如下：

![UDP数据头](https://pic002.cnblogs.com/images/2012/413416/2012120420554728.png)

- Source port 和 Destination port：分别是发出端口和目的端口；
- Length是UDP包长度
- checksum类似IP的checksum算法，但UDP校验整个数据包，包括UDP头、IP头、数据。IPv4中这里可以为0，表示不适用checksum，而IPv6则要求必须校验(IPv6自身不校验了)。
- 目的地和源地址IP在IP包中保存。



## TCP协议

TCP是传输层协议，实现了端口到端口的通信。TCP协议会将数据分成小片段，然后将片段封装到IP包中进行传输。

### 部分定义

#### 基于TCP的协议

基于TCP的应用层协议有很多：Telnet、FTP、rlogin、X Windows和SMTP，SNMP,HTTP。

不同的应用层协议有不同的需求，如FTP需要大量数据的高速传输，Telnet协议则需要高交互性。所以为了应对不同的应用层协议需求，TCP发展出了很多细节，特性，而这些细节才是TCP的精髓。

- 例如为了满足Telnet协议的高交互性，需要关闭nagle算法，但关闭nagle算法后造成大量小数据早会，资源利用率低，且会和TCP延迟确认发生冲突导致阻塞降低交互效率。
- 各种细节保证了TCP协议的可靠性和效率，但硬件一定的情况下，有时二者不可得兼，只能舍弃部分特性来满足实际需求。

#### TCP的模块

TCP的主要模块有：分段与流，滑窗，连接，流量控制，重新发送，堵塞控制。

在TCP协议中，我们使用[连接](http://www.cnblogs.com/vamei/archive/2012/12/16/2812188.html)记录TCP两端的状态，使用[编号和分段](http://www.cnblogs.com/vamei/archive/2012/12/08/2805252.html)实现了TCP传输的有序，使用[advertised window](http://www.cnblogs.com/vamei/archive/2012/12/18/2822739.html)来实现了发送方和接收方处理能力的匹配，并使用[重复发送](http://www.cnblogs.com/vamei/archive/2013/01/05/2824748.html)来实现TCP传输的可靠性。我们只需要将TCP片段包装成IP包，扔到网络中就可以了。TCP协议的相关模块会帮我们处理各种可能出现的问题(比如排序，比如TCP片段丢失等等)。最初的TCP协议就是由上述的几大块构成的。

上世纪八十年代TCP协议加入**堵塞控制(congestion control)**，原因是当时由于网络繁忙，堵塞，TCP重复发送恶性循环，导致堵塞崩溃(congestion collapse)。

#### 端口

网络层提供的逻辑上的概念。用于区分多线程操作系统中不同的用户、进程，让各个不同进程能通过不同的端口唯一对外标识、通信。

#### 最大分段大小（MSS, Maximum Segment Size）

传输控制协议的一个参数，以字节数定义一个计算机或通信设备所能接受的分段的最大数据量。 它并不会计算 TCP 或 IP 协议头的大小。含有 TCP 分段的 IP 资料包可以在一个数据包内自我包含，也可以从多个IP分片中重建。无论如何，MSS 限制都对最终重建的分段起效。

- 默认的 TCP 最大分段大小是 536。当一个主机想要把 MSS 设置到一个非默认的值时，MSS 大小会以一个 TCP 可选项的方式在握手时的 SYN 包中定义。由于最大分段大小被一个 TCP 参数控制，主机可以在接下来的任意分段中改变它。

- 每个数据流的方向都可以使用不同的 MSS。
- 对于大部分操作系统来说，最大分段大小的值由操作系统指定。

#### 重新发送超时时间(RTO)与往返时间(RTT)

发送方发送完片段后等待回复ACK的时间称作重新发送超时时间(RTO, retransmission timeout)。

$发送方发送片段到接收方的时间+接收方发送回复到发送方的时间=往返时间(RTT, round\ trip\ time)$

RTO与RTT的关系：$RTO \geq RTT​$，RTT时间上下浮动很大，取决于当前时刻网络状况，所以实际RTO应符合当前网络使用状况，并大于当前最大RTT。

TCP协议通过统计RTT来决定合适的RTO：

1. 发送方可以测量每次TCP传输的RTT（从发送片段到收到ACK位置），测得的时间称作**采样RTT(srrt, sampling round tirp time)**；
2. 然后计算各次srtt的平均值(mean)和标准差(standard deviation)；
3. 最后计算$RTO = mean + 4*std$

> 实际使用中，该公式有多个变种，不同平台具体实现略有差别。

#### TCP片段头格式：

![TCP header格式](https://pic002.cnblogs.com/images/2012/413416/2012121611481430.png)

> 如果该图失效，wiki有同样的图，还有中文的。
>
> 详细字段解释参见TCP连接一节。



### 流通信

#### 流通信

TCP虚拟了UNIX系统中的**文本流(byte stream)**通信方式（即以字节为基本单位排队成流进行数据传输）；

#### 次序(order)

流通信也就是说TCP的传输是按数据顺序依次进行的，有次序；

- 次序存在TCP片段头部(header)的序号中(sequence number)；
- 接收方会按照次序接收片段，当收到的片段不是下一个片段的话会丢弃；

#### 片段(segment)：

对于大数据包，TCP会将其分段，分成片段进行传输；

- 一个片段包含**头部(header)**和**数据(payload)**两部分；
- 每个TCP片段封装成的IP包不超过整个IP接力路径上的最小MTU；

由于TCP通信是双向的，所以要有发送和接收两个文本流，两个文本流分别独立编号。



### 可靠性（ACK）

#### 可靠性解决方案

由于IP协议不可靠，IP数据传输过程中会发生错误或者丢失，所以可靠性需要靠TCP协议来补全。

TCP的做法是：

- 发送方：收到给我回复，不回一直发。
- 接收方：收到了，回复你。还发这个序号的？继续回复。收到的次序不对？丢了，不回复。

详解：

1. **发送方**从本地一个端口发送次序为n的片段到对方一个端口，每隔一段时间就发一次；
2. **接收方**从端口接收到了数据包，查看序号：
   - 序号是n：发送ACK信号ACK中的回复号是n+1，表示期待n+1；
   - 序号不是n：丢弃，不回复；
   - 序号是n-1：前一个ACK发送方没收到，继续回复ACK；
3. **发送方**接收到ACK，发下一个次序为n+1的片段；重复行为1，直到发完并收到最后一个ACK，即共N个片段的话，收到回复号是N+1的ACK。

#### TCP片段丢失

片段丢失的原因：

- 接收方没收到
- 接收方收到了，校验和(checksum字段)出错

> 接收方没收到原因是IP包在网络中丢失，可能原因有：
>
> - IP包经历太多路由器接力，达到hop limit；
> - 路由器太拥挤，导致IP包丢弃；
> - 路由表没及时更新，导致找错目的地。
>
> TCP的校验和会校验包括IP头、TCP头、TCP数据在内的整个序列，校验和算法类似IP校验和算法。

#### 超时重发

发送方发出TCP片段后开始计时等待ACK，计时超过重新发送超市时间(RTO)后则重发当前片段。

#### 快速重发

发送方在计时到RTO之前重发片段的行为叫做快速重发(fast-retransmission)。

快速重发的原因：

- 接收方收到乱序片段后，如果该片段前还有片段没收到（出现空洞），就会回复空洞序号的ACK，每次收到空洞后的乱序片段都会重发空洞序号的ACK；

- 当发送方收到三个相同回复号的ACK后，确认该片段丢失，及时计时还未超时，也会打断计时立刻重发。

- 举例：发出片段5~11，接收方收到5679，则回复ACK8，再收到10，11，又重发两次ACK8。接收方收到三次ACK8即打断计时，重发片段8。

  > 实际应用没这么简单，首先延时确认不会收到10 11就回ACK两次，其次ACK8可能丢失。

#### ACK介绍

发送ACK需要将TCP头中ACK置1，然后再ack字段填入回复序列号。

ACK包中也可以附带数据（作为发送方发送的数据可以放在ACK包中，其实两个是同一个包，只是TCP头有一个ACK位标识这个包是不是ACK）。

一般将ACK附在其他数据片段中发送，减少ACK回复消耗的流量。

#### 累计ACK

接收方往往利用一个ACK回复来知会连续多个片段的成功接收。通过累计ACK，所需ACK回复通常可以降到50%。

当滑窗中多个片段都已到达时可以只回复最后一个片段，发送方即知前面都收到了不在发送。例如：789都到了，直接回复10，不再回89。

接收方在接收到片断，并应该回复ACK的时候，会故意延迟一些时间。如果在延迟的时间里，有后续的片段到达，就可以利用累计ACK来一起回复了，并且如果等待一段时间有接收方向发送方发送的数据，就可以”捎带“上ACK，不用纯发ACK浪费网络资源。

- 这个等待时间初始为最小值40ms左右，随后根据连接重传超时时间(RTO)、上次收到数据包与本次接收数据包的时间间隔等参数不断调整。
- 可通过设置TCP_QUICKACK选项取消确认。



### 效率

#### 提高效率的方法

效率对比：

- 一次只发一个包：
  - **发送方**会进入`发送->等待->发送`的`stop-and-wait`模式，网络通信效率低（网络数据传输效率kb/s低），多线程系统的话不占CPU执行时间和内存；
  - **接收方**则是效率挺高，收到一个包就写入磁盘一个，不占什么内存，只用一个包的内存即可；
- 一次发很多包：
  - **发送方**发出去就等，发送方效率高，网络通信效率高；
  - **接收方**收到的次序是乱序，需要大量内存去做排序，包越多占的内存越多，必须全收到，排好序才能移除内存写入磁盘；

所以实际做法：每次发送次序为n~n+k的k个包；

1. 设置一个**滑窗(sliding window)**，滑窗宽度为k，即发送方每次同时发送k个包；

2. 只有接收到滑窗头第一个包（即n）的ACK（即回复号n+1）时，滑窗才会后移到下一位，如果下一位回复也收到了在后移，直到遇到第一个还没收到回复的片段，继续发k个包；

   >  接收方还是照常收到一个包就发对应的ACK然后去拼接、写入磁盘；

由于TCP连接是双向的，所以通信的双方各自都维护两个滑窗，一个发送滑窗，一个接收滑窗。

#### nagle算法

上过bbs的人应该都会有感受，就是在网络慢的时候发贴，有时键入一串字符串以后，经过一段时间，客户端“发疯”一样突然回显出很多内容，就好像数据一下子传过来了一样，这就是Nagle算法的作用。

“小数据包问题”－某个应用程序不断地提交小单位的数据，且某些常只占1字节大小。因为TCP数据包具有40字节的标头信息（TCP与IPv4各占20字节），这导致了41字节大小的数据包只有1字节的可用信息，造成庞大的浪费。**这种状况常常发生于Telnet工作阶段－大部分的键盘操作会产生1字节的数据并马上提交。**更糟的是，在慢速的网络连线下，这类的数据包会大量地在同一时点传输，造成壅塞碰撞。

纳格算法的工作方式是合并（coalescing）一定数量的输出数据后一次提交。特别的是，只要有已提交的数据包尚未确认，发送者会持续缓冲数据包，直到累积一定数量的数据才提交。

算法：

```
 if有新資料要傳送
   if訊窗大小>= MSS and可傳送的資料>= MSS
     立刻傳送完整MSS大小的segment
   else
    if管線中有尚未確認的資料
      在下一个确认（ACK）封包收到前，将资料排进缓冲区序列
    else
      立即傳送資料  
```

**该算法与 TCP延迟确认 会有不好的相互作用**，例如当程序发送端进行两次连续的小段写再跟着读时，接收端接收到第一次写后因TCP延迟确认而等待第二次写后一并发送ACK，发送端则因第二次写数据长度小于MSS而等待第一次写的ACK（如上算法所示），最终将导致两对端都进入等待直到ACK延迟超时。

- 因为这个原因，TCP实现通常为应用程序提供一个禁用Nagle算法的接口（通常称为TCP_NODELAY选项）。
- 用户级解决方案是避免套接字上的 写-写-读 序列。 写-读-读 和 写-写-写 都是没问题的。但 写-写-读 则是性能杀手。
- 如果可以的话，缓冲你对TCP的小段写，然后一次发送它们。在每次读之前使用标准的UNIX I/O包并冲刷写缓存通常能起作用。

#### 滑窗结构

之前讨论中以片段为单位衡量滑窗的大小，实际上真实的滑窗是以byte为单位标识大小的。

发送方滑窗可以分为两部分，offered window是整个滑窗的大小：

![发送方滑窗结构](https://pic002.cnblogs.com/images/2012/413416/2012121810480069.png)

接收方滑窗可以分为三部分，多了一个“Received ACKed Not Sent to Proc”。这部分放的是接收到并回复过等待进程读取的文本流。

> 接收到的文本流必须等待进程来读，进程没读的时候就放在这里，占用内存。
>
> 如果这部分占用的内存过多，则滑窗可用部分(advertised window)就会缩水，导致接收方处理能力下降。如果发送方依然按照之前的速率发送给接收方，则接收方将无力接收。

![接收滑窗结构](https://pic002.cnblogs.com/images/2012/413416/2012121810375278.png)

#### 流量控制(flow control)

TCP协议会根据情况自动改变滑窗大小，以实现流量控制。

流量控制是指接收方将advertised window大小通知发送方，从而知道发送方修改offered window的大小，接收方将滑窗大小信息放在TCP头部window size区域（14~15Byte）。

#### 零窗口

advertised window大小可以为0，这意味着接收方的接受能力为0，发送方收到大小为0的advertised window通知时会停止发送。

当接收方经过处理，再次产生可用的advertised window时，接收方会通过纯粹的ACK回复来通知发送方，让发送方恢复发送。然而，ACK回复的传送并不是可靠的。如果该ACK回复丢失，那么TCP传输将陷入死锁(deadlock)状态。

为此，发送方会在零窗口后，不断探测接收方的窗口。窗口探测(window probe)时，发送方会向接收方发送包含1 byte文本流的TCP片段，并等待ACK回复(该ACK回复包含有window size)。由于有1 byte的数据存在，所以该传输是可靠的，而不用担心ACK回复丢失的问题。如果探测结果显示窗口依然为0，发送方会等待更长的时间，然后再次进行窗口探测，直到TCP传输恢复。

#### 白痴窗口综合症

滑窗机制有可能犯病，比如白痴窗口综合症 (Silly Window Syndrome)。假设这样一种情形：接收方宣布(advertise)一个小的窗口，发送方根据advertised window，发送一个小的片段。接收方的小窗口被填满，经过处理，接收方再宣布一个小的窗口…… 这就是“白痴窗口综合症”：TCP通信的片段中包含的数据量很小。在这样的情况下，TCP通信的片段所含的信息都很小，网络流量主要是TCP片段的头部，从而造成流量的浪费 (由于TCP头部很大，我们希望每个TCP片段中含有比较多的数据)。

如果发送方不断发送小的片段，也会造成“白痴窗口”。为了解决这个问题，需要从两方面入手。TCP中有相关的规定，要求：

1. 接收方宣告的窗口必须达到一定的尺寸，否则等待。
2. 除了一些特殊情况，发送方发送的片段必须达到一定的尺寸，否则等待。特殊情况主要是指需要最小化延迟的TCP应用(比如命令行互动)。



### TCP连接

一个连接为两个IP:port之间建立TCP通信。

两台电脑操作系统的TCP模块负责建立连接，每个连接有四个参数（(IP:port)*2共4个）标识该连接，其中一个不同就是不同的连接。

> 这意味着，同一个端口上可以有多个连接，只要对方的IP或者端口不同，就可以建立多个不同的连接。

TCP模块负责建立连接，建立后将连接分配给进程使用。

TCP连接是双向的，所以发送各方维护两个滑窗、两个文本流。

> 

#### 建立TCP连接

建立连接通过三次握手(three-way handshaking)的方式完成。

目的：让连接双方交换初始序号(ISN, Initial Sequence Number)；

建立连接相关片段头数据（其他字段解释详见[wiki](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)）：

- SYN：为1表示这是连接请求或是连接接受请求，用于创建连接和使顺序号同步，

- 序列号（seq，sequence number，32位长）

  - SYN为1：随机生成一个序列号发过去，随机生成的序列号作为最初的序列号（ISN），后面每次发新数据加一；

  - SYN为0：在上一次序列号的基础上加一发过去；

    > 使用随机初始序号而不是从0开始是为了安全，使用固定数字容易让人猜出接下来的序列号，然后伪装TCP片段混入文本流。

- 确认号（ack，Acknowledgment numger， 32位长）

  - ACK位为1，这一字段才有效；
  - 发送应答，在收到的seq的基础上加一发回去；

建立连接需要的行为：

1. 客户端发出建立连接请求：SYN置1，随机生成一个seq作为ISN（记作ISN(c)）；
2. 服务器收到后发送回复ACK并附上自己的ISN：ACK置1，SYN置1，seq填入自己随机生成的ISN（记作ISN(s)），ack填入收到的客户端的ISN(c)+1；
3. 客户端收到服务器的ISN后发送一个纯ACK不带数据的包，即成功建立连接：ACK置1，SYN置0，seq填入自己的ISN(s)+1，ack填入服务器发来的ISN(c)+1

建立连接的三次握手流程：

``` sequence
participant 客户端 as c
participant 服务端 as s
c -> s:请求建立连接,seq=ISN(c),SYN=1
s -> c:回复并发送自己的ISN，seq=ISN(s),ack=ISN(c)+1,SYN=1,ACK=1
c -> s:回复，ACK=1,seq=ISN(c)+1,ack=ISN(s)+1
note over c,s:成功建立连接
```

#### 终止连接

终止连接通过4次握手(four-way handshaking)的完成，在这个过程中连接的每一侧都独立地被终止。当一个端点要停止它这一侧的连接，就向对侧发送FIN，对侧回复ACK表示确认。因此，拆掉一侧的连接过程需要一对FIN和ACK，分别由两侧端点发出。

终止连接相关片段头数据（其他字段解释详见[wiki](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)）：

- ACK，ack，seq；
- FIN：为1表示发送方没有数据要传输了，要求释放连接。

终结连接需要的行为：

1. **发送方**发送FIN置1的正常数据包；
2. **接收方**接收到FIN为1的数据包后，发送应答信号；
3. 发送方的TCP连接终止成功。

> TCP连接允许单向关闭(half-close)，一个方向关闭后变成单向连接(half-duplex)。

终止连接四次握手流程（服务端和客户端都可以做首先终止连接的一方，这里让客户端先终止）：

``` sequence
participant 客户端 as c
participant 服务端 as s
c -> s:FIN=1,seq(ack,ACK)
s -> c:seq,ack,ACK=1
s -> c:FIN=1,seq,ack,ACK=1
c -> s:seq,ack,ACK=1
```

四次握手其实是双方各自断开单向连接的过程。

最后主动断开连接一方发送ACK时，发送完会等待2*MSL(Maximum Segment Lifetime，一个片段在网络中的最大存活时间，2MSL时一次发送+回复的最大时间)，如果再次收到FIN，则再次发送ACK，直到等待2MSL后不再收到FIN，则认为对方收到ACK，结束TCP连接。流程如下：

1. 客户端（客户端首先终止的情况下）收到FIN后发送ACK，等待2MSL；
2. 等待完2MSL后看是否收到FIN，收到则重复步骤一，没收到则结束连接。

### 堵塞控制

TCP协议的堵塞控制是通过约束自己实现的。当TCP的发送方探测到网络交通拥堵时，会控制自己发送片段的速率，以缓解网络的交通状况，避免堵塞崩溃。简言之，TCP协议规定了发送方需要遵守的“公德”。

堵塞的探测：当发送方认为TCP片段丢失时，则认为网络出现堵塞，然后会通过滑窗控制自己的发送速率。

TCP还会维护一个congestion window size，以根据网络状况来调整滑窗大小。真实滑窗大小取这两个滑窗限制的最小值，从而同时满足两个限制 (流量控制和堵塞控制)。

#### 数据拥塞：拥塞窗口(congestion window)

当传输时可能会出现瓶颈（比如说一定要经过一个slip低速链路），产生的大量数据堵塞问题（拥塞），为了解决这个问题，TCP发送方需要确认连接双方的线路的数据最大吞吐量是多少。这就是所谓的拥塞窗口。

拥塞窗口的原理很简单，TCP发送方首先发送一个数据报，然后等待对方的回应，得到回应后就把这个窗口的大小加倍，然后连续发送两个数据报，等到对方回应以后，再把这个窗口加倍（先是2的指数倍，到一定程度后就变成线性增长，这就是所谓的**慢启动**），发送更多的数据报，直到出现超时错误，这样，发送端就了解到了通信双方的线路承载能力，也就确定了拥塞窗口的大小，发送方就用这个拥塞窗口的大小发送数据。要观察这个现象是非常容易的，我们一般在下载数据的时候，速度都是慢慢“冲起来的”。

拥塞窗口总是处于两种状态的一个。这两种状态是: 慢起动(slow start)和堵塞避免(congestion avoidance)。

1. 慢启动：TCP连接开始后，窗口尺寸初值很小，每收到一次ACK就指数增加(multiplicatively)窗口尺寸；
2. 阻塞避免：窗口尺寸大于阈值ssthresh后，进入阻塞避免状态，缓慢加性(additively)增加窗口尺寸；
3. 如果慢启动或阻塞避免状态中如果有片段丢失，则$ssthresh=0.5*cwnd$，并将cwnd设置成1，然后重回慢启动状态；

> cwnd表示阻塞窗口尺寸，congestion window size

![拥塞窗口状态图](https://images0.cnblogs.com/blog/413416/201301/09213603-4787f562826f4a87b273182d6dff1f1a.png)

通过上面的机制，让发送速率处于动态平衡，不断的尝试更大值。初始时增长块，而接近饱和时增长慢。但一旦尝试过度，则迅速重置，以免造成网络负担。

#### 快速恢复

收到第三个重复的 ack 时（快重传），TCP 会把慢启动门限 ssthresh 的值设置为 cwnd 值的一半，同时 cwnd = ssthresh （在有些版本中，会让 cwnd = ssthresh + 3）。



# 应用层协议

## DNS协议

域名和IP的对应关系需要通过DNS协议从DNS服务器获取。

域名的好处：

- 便于人类记忆；
- 服务方更改IP时不影响域名，便于维护和运营。

### DNS服务器

DNS服务器是在网络中进行域名解析的一些服务器，这些服务器有自己的IP地址，并使用NDS协议进行通信，DNS协议基于UDP协议。

![DNS服务器解析域名方式](https://images0.cnblogs.com/blog/413416/201301/11110946-31e93a6651e74527ac8cce91de4afc83.png)

DNS服务器构成一个分级(hierarchical)的树状体系。上图中，每个节点(node)为一个DNS服务器，每个节点都有自己的IP地址。树的顶端为用户电脑出口处的DNS服务器。在Linux下，可以使用cat /etc/resolv.conf，在Windows下，可以使用`ipconfig /all，来`查询出口DNS服务器。树的末端是真正的域名/IP对应关系记录。一次DNS查询就是从树的顶端节点出发，最终找到相应末端记录的过程。

中间节点根据域名的构成，将DNS查询引导向下一级的服务器。比如说一个域名cs.berkeley.edu，DNS解析会将域名分割为cs, berkeley, edu，然后按照相反的顺序查询(edu, berkeley, cs)。出口DNS首先根据edu，将查询指向下一层的edu节点。然后edu节点根据berkeley，将查询指向下一层的berkeley节点。这台berkeley服务器上存储有cs.berkeley.edu的IP地址。所以，中间节点不断重新定向，并将我们引导到正确的记录。

在整个DNS查询过程中，无论是重新定向还是最终取得对应关系，都是用户计算机和DNS服务器使用DNS协议通信。用户计算机根据DNS服务器的反馈，依次与下一层的DNS服务器建立通信。用户计算机经过递归查询，最终和末端节点通信，并获得IP地址。

> 用户计算机的操作系统中的域名解析模块(DNS Resolver)负责域名解析的相关工作。任何一个应用程序(邮件，浏览器)都可以通过调用该模块来进行域名解析。
>
> 并不是每次域名解析都要完整的经历解析过程。DNS Resolver通常有DNS缓存(cache)，用来记录最近使用和查询的域名/IP关系。在进行DNS查询之前，计算机会先查询cache中是否有相关记录。这样，重复使用的域名就不用总要经过整个递归查询过程。



## HTTP协议

HTTP协议通信**是一次request-responce交流。**客户端(guest)向服务器发出请求(request)，服务器(server)回复(response)客户端。

- 早期的HTTP协议，每次request-reponse时，都要重新建立TCP连接。TCP连接每次都重新建立，所以服务器无法知道上次请求和本次请求是否来自于同一个客户端。因此，HTTP通信是无状态(stateless)的。服务器认为每次请求都是一个全新的请求，无论该请求是否来自同一地址。
- 随着HTTP协议的发展，HTTP协议允许TCP连接复用，以节省建立连接所耗费的时间。但HTTP协议依然保持无状态的特性。

### HTTP协议格式

HTTP请求和回复的格式都一样：

``` 
起始行 (start line)
头信息 (headers)

主体(entity body)
```

- 起始行：只有一行，包含了请求/回复最重要的信息；

  - 如：GET /index.html HTTP/1.1

- 头信息：可以有很多行，每一行是一对键值对(key-value pair)；

  - 如：

    ```
    Content-type: text/plain
    Host: www.example.com
    ```

    

- 主体：包含了具体资源，例如HTML等。

### 请求

GET方法，向服务器请求某一资源，请求的资源跟在GET后面。

如：请求/index.html页面

``` 
GET /index.html HTTP/1.1
Host: www.example.com
```

GET方法也可以用于传输一些不重要的数据。它是通过改写URL的方式实现的。GET的数据利用URL?变量名＝变量值的方法传输。

如：向127.0.0.1发送一个值为a的变量q。

```
GET http://127.0.0.1?q=a HTTP/1.1
```

GET方法之外，最常用的是POST方法。它用于从客户端向服务器提交数据。使用POST方法时，URL不再被改写。数据位于http请求的主体。POST方法最用于提交HTML的form数据。服务器往往会对POST方法提交的数据进行一定的处理，比如存入服务器数据库。

样例请求中有一行头信息。该头信息的名字是Host。HTTP的请求必须有Host头信息，用于说明服务器的地址和端口。HTTP协议的默认端口是80，如果在HOST中没有说明端口，那么将默认采取该端口。在该例子中，服务器的域名为`www.example.com`，端口为80。域名将通过DNS服务器转换为IP地址，从而确定服务器在互联网上的地址。

### 回复

服务器在接收到请求之后，会根据程序，生成对应于该请求的回复。

如：

```
HTTP/1.1 200 OK
Content-type: text/plain
Content-length: 12

Hello World!
```

起始行包括三个信息

- HTTP/1.1 协议版本
- 200 状态码(status code)，这个是程序看的，200表示OK，资源返回正常
- OK 状态描述，这个是给人看的，对于状态码的描述

## DHCP协议

DHCP协议用于动态的配置电脑的网络相关参数，如主机的IP地址，路由器出口地址、DNS域名服务器地址等。一台电脑只要接上网，就可以通过DHCP协议获得相关配置，从而顺利的畅游网络。

DHCP协议全称为“动态主机设置协议”（Dynamic Host Configuration Protocol）。通常来说，普通电脑中都内置有DHCP客户端模块。电脑接上网络后，DHCP客户端发现新连通的网络，会在该网络上找DHCP服务器。DHCP服务器将给电脑提供合理的网络配置，并把设置信息传回本机。所谓的DHCP服务器，其实就是一些运行有DHCP服务器端软件的特殊电脑。他们像等候在网络上的服务员，为新来的顾客排忧解难。本机和DHCP服务器之间的通信，都是通过DHCP协议进行的。

### DHCP服务器功能

平时用到的DHCP服务器就是路由器中的DHCP功能。所以看路由器的DHCP功能基本就能知道DHCP服务器的主要功能：

- 动态分配地址，根据DHCP服务器的地址池给新设备分配IP地址；
- 静态分配地址，给特定MAC地址的设备分配固定IP地址，这个一般是手动设置并永久占用，不管设备是否在线；
- 设定租期，超时要么延期、要么收回；
- 提供DNS服务器地址、网络出口地址配置信息，这些可以由DHCP提供，也可以客户机自己设置，不适用DHCP提供的这些信息。

### 通信方式

1. Discovery：客户机发UDP广播，搜寻DHCP服务器。
2. Offer：DHCP服务器发出邀请，提供一个可用的IP地址。
3. Request：客户机正式请求使用该IP地址。
4. Acknowledge：DHCP服务器确认，并提供其他配置参数。

### DHCP攻击

前提：攻击者接入局域网；

手段：

1. 申请空DHCP服务器的地址池；
2. 自己装作DHCP服务器，提供假的DNS服务器或网络出口；
3. 把用户解析的域名结果导向自己这里，窃取信息。

DHCP协议在设计中并没有考虑到安全性的问题，所以很难从软件上杜绝DHCP攻击。某些品牌的交换机上，可以指定特定端口给合法的DHCP服务器，以免其他人伪装。当然，最重要的保护方式，还是防止攻击者连入局域网。

###  TLS和SSL协议

TLS名为传输层安全协议(Transport Layer Security Protocol)，这个协议是一套加密的通信协议。它的前身是SSL协议(安全套接层协议，Secure Sockets Layer)。这两个协议的工作方式类似，但TLS协议针对SSL协议进行了一些改善。SSL/TLS协议利用加密的方式，在开放的互联网环境中实现了加密通信，让通信的双方可以安心的说悄悄话。

### SSL协议

SSL协议通信步骤：

1. 双方利用明文通信的方式确立使用的加密算法。
2. 利用非对称算法通信，交换一个密钥。
3. 该密钥用于对称加密算法，加密接下来的通信正文。

> 对称加密(symmetric encryption)是将密钥发给对方，然后双方通过密钥加密解密，运算成本低，但密钥是明码发送的，被截获则不安全。
>
> 非对称加密(asymmetric encryption)是发出公钥，自己留着私钥进行解密，更安全，但运算成本高。
>
> 为了兼顾效率和安全，SSL协议同时使用了非对称和对称加密。它用对称加密算法来加密信息本身。但对于安全性比较脆弱的对称加密密钥，则采用非对称加密的方式来传输。

SSL对称密钥交换过程：

1. 客户发起请求时，除了说明自己支持的非对称加密算法，还会附加一个客户端随机数(client random)。
2. 服务器回复请求时，会确定非对称加密算法和哈希函数，并附上公钥。此外，服务器端还会在此次通信中附加一个服务器端随机数(server random)。
3. 客户端会产生第三个随机数(Premaster secret)，然后利用服务器确定的非对称加密算法和公钥来加密这个随机数，再发送给服务器端。
4. 客户端用自己的私钥解密第三个随机数。
5. 这样，客户端和服务器端都知道了三个随机数。双方各自用商量好的哈希函数从三个随机数获得对称加密的密钥。

> 即使明文通信的时候，某些信息被窃听，但第三步的非对称加密通信部分可以保证窃听者无法完整的获得三个随机数。这样，窃听者还是不知道对称加密的密钥是什么。这样，对称加密的密钥就在一个安全的环境中获得了。为了进一步安全，服务器的公钥会包含在一个数字证书中发送给客户。这样，客户还可以通过数字证书来验证服务器的身份，以免服务器本身出现问题。 

HTTP协议经过多重路由容易被窃听，而HTTPS协议是在SSL/TLS的基础上进行通信，更安全，浏览器上带个锁的都是HTTPS协议：

![浏览器HTTPS标识](https://images2015.cnblogs.com/blog/413416/201610/413416-20161008012222582-1535342918.png)

# 网络诊断工具

ifconfig：

- windows中是ipconfig，Ubuntu18开始时`ip a`。

- 显示网络接口(interface)信息。如接口名称，接口类型，接口的IP地址，硬件的MAC地址等。

arp：

- `arp -a` 显示本地存储的IP-MAC对应关系；

- `sudo arping -I eth0 192.168.1.1`，经过eth0接口发送ARP请求查询IP地址为192.168.1.1的设备对应的MAC地址；

- `sudo arp-scan -l`查询整个局域网内的所有IP地址对应MAC地址；

- `sudo tcpdump -i en0 arp`监听en接口的arp通信协议

  > 通过ARP工具，我们可以知道局域网内的通信是否正常。

ping：

- `ping 192.168.1.1`向IP地址192.168.1.255发送ICMP请求。如果该地址的ICMP没有被禁用，那么在该网上的设备将回复。
- `ping 192.168.1.255` 向广播(broadcast)地址192.168.1.255发送ICMP请求。如果ICMP没有被禁用，那么在该网上的设备将回复。

> 需要注意的是，许多设备会禁用ICMP。如果ping不到一个设备，并不一定是网络层故障。windows下如果禁用可以修改入站规则开启。

netstat：

- `netstat -nr`显示路由表。从路由表中，可以找到网关(Gateway)。网关是通向更加广域网络的出口。

traceroute：

- `traceroute 74.125.128.99`追踪到达IP目的地的全程路由。
- `traceroute -I 74.125.128.99`通过ICMP协议，追踪路由。ICMP协议经常会被禁用，所以会返回"*"的字符串。
- `sudo traceroute -T -p 80 74.125.128.99`通过TCP协议，经80端口，追踪路由。TCP协议的默认端口80很少会被禁用。

tcpdump：

- `sudo tcpdump -i en0`监听en0接口的所有通信

- `sudo tcpdump -A -i en0`用ASCII显示en0接口的通信内容

- `sudo tcpdump -i en0 'port 8080'`显示en0接口的8080端口的通信

- `sudo tcpdump -i eth1 src 192.168.1.200`显示eth1接口，来自192.168.1.200的通信

- `sudo tcpdump -i eth1 dst 192.168.1.101 and port 80`显示eth1接口80端口，目的地为192.168.1.101的通信

- `sudo tcpdump -w record.pcap -i lo0`将lo0接口的通信存入文件record.pcap

  > tcpdump是一款网络抓包工具。它可以监听网络接口不同层的通信，并过滤出特定的内容，比如特定协议、特定端口等等。我们上面已经使用tcpdump监听了ARP协议通信。这里我们来看更多的监听方式。

host：

- `host www.sina.com.cn`DNS域名解析。返回域名对应的IP地址