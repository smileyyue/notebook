# ucoreOS课程lab6处理机调度

[TOC]

## 概述

定义：

- 单CPU：从就绪队列中挑选下一个占用CPU运行的进程
- 多CPU：从多个可用的CPU中挑选就绪进程可用的CPU资源
- 调度程序：挑选就绪进程的内核函数

调度时机

- 非抢占系统：当前进程主动放弃CPU，系统不会主动剥夺
  - 进程从运行状态切换到等待状态时，调用调度函数执行调度
  - 进程被终结，调用调度函数执行调度
- 抢占系统：有中断请求被服务例程相应完成时会进行调度
  - 进程时间片用完后触发时钟中断进行调度
  - 进程从等待切换到就绪时，如果优先级较高，则调度、抢占

## 调度算法

### 调度策略

处理机资源使用模式：进程在CPU计算和I/O操作间交替执行，当执行I/O操作时，CPU处于等待状态(I/O操作例如：读文件、使用外设）。因为交替执行，所以进程使用CPU的时间一般都很短，需要长时间进行CPU计算的只有少数。

调度效果评估准则：

- CPU使用率：CPU处于忙状态的时间百分比
- 吞吐量：单位时间完成的进程数量
- 周转时间：进程从初始化到结束（包括等待）的总时间
- 等待时间：进程在就绪队列中的总时间
- 响应时间：从提交请求到产生响应所花费的总时间

> 用户对调度算法要求“快”：传文件时高带宽，要求调度算法的高吞吐量；玩游戏时低延迟，要求调度算法的低响应延迟。

调度目标：

- 减少响应时间：及时处理用户的输入请求，尽快将输出反馈给用户
- 减少平均响应时间的波动：在交互系统中，可预测性（响应时间稳定，方差小）比高差异低平均（响应时间波动大、极值大）更重要
- 增加吞吐量
  - 减少开销（操作系统开销，上下文切换）
  - 系统资源高效利用（CPU，I/O设备）
- 减少等待时间：减少每个进程的等待时间
- 操作系统要保证吞吐量不受用户交互影响，操作系统必须不时进行调度，即使存在许多用户交互任务。

> 吞吐量是操作系统的计算带宽

公平性定义

- 保证每个进程占用的CPU时间相同（各个用户占用CPU时间可能不同）
- 保证每个进程的等待时间相同

> 为了保证公平性，需要操作系统额外付出一些开销

### 就绪队列排序算法

#### 先来先服务算法（FCFS:First Come, First Served）

先来先服务。

优点：

- 简单

缺点：

- 平均等待时间波动较大：短进程可能排在长进程后面，等待时间就很长，反过来等待时间很短
- 资源利用率低：CPU密集型进程会导致I/O设备闲置时，I/O密集型进程也在等待不能调度执行，导致I/O闲置浪费

#### 短进程优先算法及其改进

##### SPN:Shortest Process Next （短进程优先算法）

对FIFO对于缺点1的优化，选择就绪队列中执行时间最短的进程。

进程执行时间不可知，所以按预期执行时间来排序

##### SJF:Shortest Job First（短作业优先算法）

SPN算法的可抢占改进。当新来一个就绪进程，其预期执行时间比当前正在执行的进程剩余执行时间还要短的时候，允许该进程抢占。

优点：

- 具有最优的平均周转时间

缺点：

- 可能会导致长进程饥饿：连续的段进程流会使长进程无法获得CPU资源
- 需要预知未来：需要预估下一个CPU计算的持续时间，
  - 解决方法1：询问用户，用户欺骗系统则到时杀死进程，用户不知道则无法预估
  - 解决方法2：用过去预测未来

解决方法2：用历史的执行时间来预估未来的执行时间

预估公式：$\tau_{n+1} = {\alpha}t_n + (1-\alpha)\tau_n, 0\leq\alpha\leq1$

- $t_n$：第n次的CPU计算时间

- $\alpha$：衰减系数，降低前面次数的权重。$\alpha$越大，下次预估时间越偏向实际计算时间，反之下次预估时间更偏向上次预估时间。

  > 公式展开为：$\tau_{n+1} = {\alpha}t_n + (1-\alpha)t_{n-1} + (1-\alpha)(1-\alpha)t_{n-2}+... $，前项权重逐次衰减。

- $\tau_n$：第n次的预估时间
- 该公式用前n次的实际计算时间和前n次的预估时间进行矫正来得到第n+1次的预估时间。
- - 

##### SRT:Shortest Remaining Time（短剩余时间有优先算法）

#### 最高响应比优先算法（HRRN:Highest Response Ratio Next）

同时考虑进程等待时间和执行时间进行排序，选择就绪队列中响应比$R = \frac{(w+s)}{s}$最高的进程，其中w(waiting time)等待时间，s(service time)执行时间

特点：

- SPN添加等待时间因素的改进
- 不可抢占
- 关注进程的灯亮时间
- 防止无限期推迟导致饥饿

### 每次执行时间长短的控制

#### 时间片轮转算法（RR:Round Robin）

在就绪队列排序算法的基础上，加入一个最长时间片限制，时间到必须用就绪队列排序算法挑出一个新进程执行。

开销：额外的上下文切换。

时间片长度：10ms左右，这是一个经验值，10ms时上下文切换的开销在1%左右。

特点：公平、平均等待时间较长，但交互性比较好。

### 多级反馈队列算法（MFQ:Multilevel Feedback Queues）

#### 多级队列调度算法(MQ)

将就绪队列分程多个子队列，不同队列可以有不同的排序算法，并可调整一个进程所在的队列。

如：前台进程一个队列（交互，低延迟，RR）、后台进程一个队列（批处理，高吞吐，FCFS）

队列间的调度：

1. 固定优先级，如：前台优先级高，先处理前台，缺点：可能会出现后台饥饿
2. 时间片轮转：每个队列得到一个确定的能够调度其进程的CPU总时间，例如前台80%，后台20%

#### 改进：多级反馈队列算法(MLFQ)

进程可在不同队列间移动的多级队列算法

优先级越低，时间片越大

如果进程当前时间片用完进程还没完成，则降到下一优先级

特征：

- CPU密集型的进程优先级下降很快，时间片分的很大，切换开销变小
- I/O密集型的进程停留在高优先级
- 可以多种算法集成，用于不同队列
- 这也是实际使用中用到的

### 公平共享调度算法（FSS:Fair Share Scheduling）

保证每个进程占用的资源是相对公平的前提下进行调度。

FSS控制用户对系统资源的访问，一些用户组比其他用户组更重要，保证不重要的用户组无法垄断资源。

未使用的资源按比例分配，没有用到自己资源使用率目标上限的用户组获得更高的优先级。

### 多种调度算法综合框架

## 实时调度

定义：正确性依赖于其时间和功能两方面的操作系统。

性能指标：

- 时间约束的及时性(deadlines)
- 速度和平均性能相对不重要

实时任务：有截止时间的任务，必须在截止时间前执行完成

周期实时任务：周期触发的实时任务

硬时限(Hard deadline)：错过任务时限会导致灾难性或非常严重的后果，必须验证在最坏的情况下能满足时限。

软时限(Soft deadline)：通常能满足任务时限，有时不能满足则降低要求，尽力保证满足。

实时调度：调度机通过调度算法，去满足实时任务的时限要求。

静态优先级调度：事先确定调度顺序

- 速率单调调度算法(RM, Rate Monotonic)：通过周期安排优先级，周期越短优先级越高，执行周期最短的任务。可证：使用率低于某值时该算法可成功调度。

动态优先级调度：执行过程中确定顺序

- 最早截止时间优先算法(EDF, Earliest Deadline First)：截止时间越早优先级越高，执行截止时间最早的任务

> 这里只是举例，实际算法不止这两个。

## 多处理机调度

特征：

- 多个处理及组成一个多处理机系统
- 处理机间可负载共享

目前用的最多的是对称多处理机系统，采用对称多处理器调度(SMP, Symmetric multiprocessing)。

SMP特点：

- 截止时间越早优先级越高，每个处理器运行自己的调度程序
- 调度程序对共享资源的访问需要进行同步

对称多处理器的进程分配

- 静态进程分配：进程开始时分配一次，之后就一直在一个固定的处理器上执行到结束，每个处理器都有自己的就绪队列，调度开销小，但各处理器可能忙闲不均。
- 动态进程分配：进程在执行中可分配到任意空闲处理机执行，所有处理机共享一个公共的就绪队列，调度开销大，各处理机负载均衡。

> 实际使用时动态静态都有用到。

## 优先级反置(Priority Inversion)

定义：操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象，基于优先级的可抢占调度算法都存在优先级反置的问题。

举例：

1. 优先级40的进程T1运行占用资源L1
2. 优先级50的进程T2申请L1，进入等待状态
3. 优先级46的进程T3抢占T1进入运行状态，T1进入等待状态，但未释放L1，T2也等待
4. T3长时间运行导致高优先级的T2长时间等待，本来T2优先级比T3高，应该能抢占T3运行的

解决方法：

1. 优先级继承(Priority Inheritance)：低优先级进程继承申请资源的高优先级进程的优先级（T1优先级变为T2的50）。

   > 只有当低优先级进程被阻塞时优先级才会提高，例如：T1运行到一半被T2抢先，**T1阻塞T2执行**，但T2需要L1，就把T1的优先级提高50，**让T1先执行T2阻塞**，执行到T1释放L1后T1优先级复原，**T1阻塞T2继续执行**。由于从T2抢占开始，T1T2优先级都是50，所以T3无法抢占。

2. 优先级天花板协议(Priority Ceiling Protocol)：占用资源进程的优先级和所有可能申请该资源的进程中最高优先级相同。不管是否发生等待，都提升占用资源进程的优先级，但容易发生优先级滥用的情况，大家优先级都高，导致优先级失效。

> 这两种是理论做法，实际使用与这种区别很大，例如第二种其实也是预测未来。

# 实验部分

## 调度流程

### 进程切换过程

``` mermaid
graph LR
A[进程A用户态] --> |trap|B[进程A内核态]
B --> |shcedule->proc_run->switch_to|C[进程B内核态]
C --> |iret|D[进程B用户态]
```



进程A用户态->内核态

### 调度点：触发调度的相关函数

即调用schedule()函数的函数有哪些：

| 位置             | 原因                                                         |
| ---------------- | ------------------------------------------------------------ |
| proc.c:do_exit   | 用户线程执行结束，主动放弃CPU                                |
| proc.c:do_wait   | 用户线程进入等待状态（目前是等待子进程结束），主动放弃CPU    |
| proc.c:init_main | initproc内核线程等待所有用户进程结束，所有用户进程结束后回收系统资源 |
| proc.c:cpu_idle  | idleproc内核线程，空闲线程，等待有就绪进程就执行调度         |
| sync.h:lock      | 进程如果无法得到锁，则主动放弃CPU                            |
| Trap.c:trap      | 时间中断触发，修改当前进程时间片，若时间片用完，则设置need_resched为1，让当前进程放弃CPU |

## 相关数据结构

### 调度器管理接口结构体

``` c
// The introduction of scheduling classes is borrrowed from Linux, and makes the 
// core scheduler quite extensible. These classes (the scheduler modules) encapsulate 
// the scheduling policies. 
struct sched_class {
    // the name of sched_class
    const char *name;
    // Init the run queue
    void (*init)(struct run_queue *rq);
    // put the proc into runqueue, and this function must be called with rq_lock
    void (*enqueue)(struct run_queue *rq, struct proc_struct *proc);
    // get the proc out runqueue, and this function must be called with rq_lock
    void (*dequeue)(struct run_queue *rq, struct proc_struct *proc);
    // choose the next runnable task
    struct proc_struct *(*pick_next)(struct run_queue *rq);
    // dealer of the time-tick
    void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);
    /* for SMP support in the future
     *  load_balance
     *     void (*load_balance)(struct rq* rq);
     *  get some proc from this rq, used in load_balance,
     *  return value is the num of gotten proc
     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);
     */
};
```

### 运行队列结构体

运行队列以链表的形式组织

``` c
struct run_queue {
    list_entry_t run_list;		// 其运行队列的哨兵结构，可以看作是队列头和尾
    unsigned int proc_num;		// 表示其内部的进程总数
    int max_time_slice;			// 每个进程一轮占用的最多时间片
    // For LAB6 ONLY
    skew_heap_entry_t *lab6_run_pool;// lab6运行池，优先队列形式的进程容器，只在 LAB6 中使用
};
```

